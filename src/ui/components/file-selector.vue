<template>
  <label class="file-selector">
    <input type="file" accept=".log" @change="onChange" />
    <span>{{ label }}</span>
    <div v-if="statusMessage" class="status">{{ statusMessage }}</div>
  </label>
</template>

<script setup>
import { ref } from 'vue';

const label = ref('📁 选择日志');
const statusMessage = ref('');

const emit = defineEmits(['file-loaded']);

// 实例化 Worker
const worker = new Worker(URL.createObjectURL(new Blob(["(function () {\n  'use strict';\n\n  /**\r\n   * 从原始日志中提取有效段落\r\n   * @param {string} rawLog 原始日志文本\r\n   * @returns {{\r\n   *   lmemSections: string[],\r\n   *   timestepSections: string[],\r\n   *   chip: Object\r\n   * }}\r\n   */\r\n  function extractValidSections(rawLog) {\r\n    const sections = rawLog.split(/(?=; action = \\w+)/g);\r\n\r\n    /* 1. 芯片规格段落（只取第一条） */\r\n    const chipSection = sections.find(sec =>\r\n      sec.includes('; action = lmem_assign') && sec.includes('; step = lmem_spec')\r\n    );\r\n\r\n    /* 2. 解析芯片字段 */\r\n    const chip = {};\r\n    if (chipSection) {\r\n      const regex = /;\\s*(\\w+)\\s*=\\s*([^;]+)/gi;\r\n      let m;\r\n      while ((m = regex.exec(chipSection)) !== null) {\r\n        const [, key, val] = m;\r\n        if (['lmem_bytes', 'lmem_banks', 'lmem_bank_bytes'].includes(key)) {\r\n          chip[key] = Number(val.trim());\r\n        }\r\n      }\r\n      console.log('[extractValidSections] 芯片信息:', chip);\r\n    }\r\n\r\n    /* 3. lmem_assign + iteration_result 段落（不含芯片段落） */\r\n    const lmemSections = sections.filter(\r\n      sec =>\r\n        sec.includes('; action = lmem_assign') &&\r\n        sec.includes('; tag = iteration_result') &&\r\n        !sec.includes('; step = lmem_spec')\r\n    );\r\n\r\n    /* 4. timestep  */\r\n    const timestepSections = sections\r\n      .filter(\r\n        sec =>\r\n          sec.includes('; action = timestep_assign') &&\r\n          sec.includes('; tag = final_result')\r\n      )\r\n      .slice(-1);  // 只取最后一个\r\n\r\n    return { lmemSections, timestepSections, chip };\r\n  }\n\n  class LmemParser {\r\n    static FIELDS_WHITELIST = new Set([\r\n      'op_name',\r\n      'op_type',\r\n      'addr',\r\n      'size',\r\n      'timestep_start',\r\n      'timestep_end',\r\n      'lmem_type',\r\n      'hold_in_lmem',\r\n      //'allow_bank_conflict',\r\n      //'one_loop',\r\n      //'shape_secs',\r\n      'status',\r\n      'tag',\r\n      'bank_id',\r\n    ]);\r\n    constructor() {\r\n      this.maxTimestepGlobal = 0;\r\n    }\r\n\r\n  getGlobalMaxTimestep() {\r\n    return this.maxTimestepGlobal;\r\n  }\r\n\r\n    /**\r\n     * 解析并处理LMEM分配数据\r\n     * @param {string[]} lmemSections 预处理后的 LMEM 日志段落数组\r\n     * @returns {{settings: Object, allocations: LmemAllocation[]}[]}\r\n     */\r\n    parse(lmemSections) {\r\n      const rawGroups = this._groupBySettings(lmemSections);\r\n      return this._processAllocationGroups(rawGroups);\r\n    }\r\n\r\n    // 按配置分组原始数据\r\n    _groupBySettings(sections) {\r\n      const groups = [];\r\n      let currentGroup = null;\r\n\r\n      sections.forEach(section => {\r\n        const { entry, settings } = this._parseSection(section);\r\n        if(!entry) return;\r\n\r\n        // 新配置组检测\r\n        if (!currentGroup || !this._isSameSettings(currentGroup.settings, settings)) {\r\n          currentGroup = { settings, allocations: [] };\r\n          groups.push(currentGroup);\r\n        }\r\n\r\n        currentGroup.allocations.push(entry);\r\n      });\r\n\r\n      return groups;\r\n    }\r\n\r\n    // 解析单个日志段落\r\n    _parseSection(section) {\r\n      const entry = {};\r\n      const settings = {};\r\n      const fieldRegex = /; (\\w+) = ([^;]+)/g;\r\n      //const fieldRegex = /;\\s*(\\w+)\\s*=\\s*([^;]+)/gi;\r\n\r\n      let match;\r\n      while ((match = fieldRegex.exec(section)) !== null) {\r\n        const [_, key, rawValue] = match;\r\n        const value = this._convertValue(key, rawValue.trim());\r\n        \r\n\r\n        if (key === 'shape_secs' || key === 'allow_bank_conflict') {\r\n          settings[key] = value;\r\n        }\r\n\r\n        if (this.constructor.FIELDS_WHITELIST.has(key)) {\r\n          entry[key] = value;\r\n        }\r\n      }\r\n\r\n      return {\r\n        entry: this._validateEntry(entry),\r\n        settings\r\n      };\r\n    }\r\n\r\n    // 处理分组数据（包含失败分配的重定位）\r\n    _processAllocationGroups(groups) {\r\n      return groups.map(group => {\r\n        const { settings, allocations } = group;\r\n        const { success, failed } = this._splitByStatus(allocations);\r\n\r\n        // 计算成功分配的最大地址\r\n        const maxAddr = success.reduce((max, alloc) => \r\n          Math.max(max, alloc.addr + alloc.size), 0);\r\n\r\n        // 重定位失败分配\r\n        let currentAddr = maxAddr;\r\n        const relocated = failed.map(alloc => {\r\n          const newAlloc = { ...alloc, addr: currentAddr };\r\n          currentAddr += alloc.size;\r\n          return newAlloc;\r\n        });\r\n\r\n        // 计算最大时间步\r\n        const maxTimestep = Math.max(\r\n          ...success.map(a => a.timestep_end),\r\n          ...failed.map(a => a.timestep_end)\r\n        );\r\n        // 更新全局最大时间步记录\r\n        this.maxTimestepGlobal = Math.max(this.maxTimestepGlobal, maxTimestep);\r\n\r\n        return {\r\n          settings,\r\n          allocations: [\r\n            ...success,\r\n            ...relocated\r\n          ].map(alloc => ({\r\n            ...alloc,\r\n            bank_id: (alloc.addr >> 16) & 0xF,\r\n            max_timestep: maxTimestep\r\n          }))\r\n        };\r\n      });\r\n    }\r\n\r\n    // 按状态分类\r\n    _splitByStatus(allocations) {\r\n      return allocations.reduce((acc, alloc) => {\r\n        if (alloc.status === 'success') {\r\n          acc.success.push(alloc);\r\n        } else {\r\n          acc.failed.push(alloc);\r\n        }\r\n        return acc;\r\n      }, { success: [], failed: [] });\r\n    }\r\n\r\n    // 配置比较\r\n    _isSameSettings(a, b) {\r\n      return ['shape_secs', 'allow_bank_conflict'].every(\r\n        key => JSON.stringify(a[key]) === JSON.stringify(b[key])\r\n      );\r\n    }\r\n\r\n    _convertValue(key, value) {\r\n      value = value.trim();   // ← 先去掉首尾空格、换行\r\n      // 布尔型字段\r\n      if (['hold_in_lmem', 'allow_bank_conflict', 'one_loop'].includes(key)) {\r\n        return value === '1' || value.toLowerCase() === 'true';\r\n      }\r\n      \r\n      // 数值型字段\r\n      if (value.startsWith('0x')) return parseInt(value, 16);\r\n      if (!isNaN(value)) return Number(value);\r\n      \r\n      // 数组型字段\r\n      if (key === 'shape_secs') return value.split(',').map(Number);\r\n      \r\n      // 字符串字段（去除引号）\r\n      return value.startsWith('\"') && value.endsWith('\"') \r\n        ? value.slice(1, -1) \r\n        : value;\r\n    }\r\n\r\n    _validateEntry(entry) {\r\n      if(entry.tag === 'stamp') return null;\r\n\r\n      const requiredFields = [\r\n        'op_name', 'addr', 'size',\r\n        'timestep_start', 'timestep_end',\r\n        'status', 'tag'\r\n      ];\r\n      \r\n      return requiredFields.every(field => field in entry) &&\r\n             entry.tag === 'iteration_result'\r\n        ? entry\r\n        : null;\r\n    }\r\n  }\n\n  class TimestepParser {\r\n    /**\r\n     * @param {string[]} timestepSections 预处理后的Timestep段落\r\n     * @returns {TimestepAssignment[]}\r\n     */\r\n    parse(timestepSections) {\r\n      if (timestepSections.length === 0) return [];\r\n      \r\n      const section = timestepSections[0];\r\n      const lines = section.split('\\n')\r\n        .filter(line => line.includes('; ts ='));\r\n      \r\n      return lines.map(line => {\r\n        try {\r\n          return this._parseTimestepLine(line);\r\n        } catch (e) {\r\n          console.warn('解析timestep行失败:', e.message);\r\n          return null;\r\n        }\r\n      }).filter(Boolean);\r\n    }\r\n\r\n    _parseTimestepLine(line) {\r\n      const tsMatch = line.match(/; ts = (\\d+);/);\r\n      if (!tsMatch) throw new Error('无效的时间步格式');\r\n      \r\n      return {\r\n        ts: parseInt(tsMatch[1]),\r\n        compute: this._extractOperations(line, 'C'), // 计算操作\r\n        loads: this._extractOperations(line, 'L'),   // 加载操作\r\n        stores: this._extractOperations(line, 'S')   // 存储操作\r\n      };\r\n    }\r\n\r\n    _extractOperations(line, type) {\r\n      if (type === 'C') {\r\n        // 捕获两个括号里的字符串：C(\"...\") 和 \"...\"\r\n        const regex = /C\\(\"([^\"]+)\"\\)[^\"]*\"([^\"]+)\"/g;\r\n        return [...line.matchAll(regex)].map(([_, id1, id2]) => ({\r\n          id: `${id2}`,   // 合并记录 `${id1} (${id2})`\r\n          type: 'compute',\r\n          operation: `${id1}`\r\n        }));\r\n      }\r\n      // type 为 L或S\r\n      const regex = new RegExp(`${type}\\\\(\"([^\"]+)\", hold_in_lmem = (\\\\d)\\\\)->([^,\\\\]]+)`, 'g');\r\n      return [...line.matchAll(regex)].map(([_, id, hold, target]) => ({\r\n        id,\r\n        hold_in_lmem: parseInt(hold),\r\n        target,\r\n        type: type === 'C' ? 'compute' : type.toLowerCase()\r\n      }));\r\n    }\r\n  }\n\n  class MemoryStatistics {\r\n      constructor() {\r\n          this.lmemGroups = [];\r\n          this.statisticsBySettings = [];\r\n          this.summaryCache = null;\r\n          this.tsCounts = 0;\r\n      }\r\n\r\n      /**\r\n       * 设置LMEM分组数据\r\n       * @param {Array} lmemGroups - LmemParser解析后的分组数据\r\n       */\r\n      setLmemData(lmemGroups, tsCounts) {\r\n          this.lmemGroups = lmemGroups;\r\n          this.tsCounts = tsCounts;\r\n          // console.log('[MemoryStatistics] 设置LMEM数据，时间步总数:', this.tsCounts);\r\n          this.summaryCache = null; // 清除缓存\r\n      }\r\n\r\n      /**\r\n       * 预计算所有配置组的内存统计\r\n       * @returns {Object} 包含所有配置组统计和全局摘要的缓存对象\r\n       */\r\n      calculateAllStatistics() {\r\n          // 如果缓存存在则直接返回\r\n          if (this.summaryCache) {\r\n              return this.summaryCache;\r\n          }\r\n          \r\n          this.statisticsBySettings = [];\r\n          \r\n          if (!this.lmemGroups.length) {\r\n              console.warn('缺少LMEM数据');\r\n              return this._createEmptyCache();\r\n          }\r\n\r\n          // 为每个settings组分别计算统计\r\n          for (const group of this.lmemGroups) {\r\n              const groupStats = this.calculateStatisticsForGroup(group);\r\n              this.statisticsBySettings.push(groupStats);\r\n          }\r\n          \r\n          // 创建并返回缓存对象\r\n          this.summaryCache = {\r\n              groups: this.statisticsBySettings,\r\n              globalSummary: this.calculateGlobalSummary()\r\n          };\r\n          \r\n          return this.summaryCache;\r\n      }\r\n\r\n      /**\r\n       * 为单个settings组计算统计\r\n       * @param {Object} group - 包含settings和allocations的组\r\n       * @returns {Object} 该组的统计信息\r\n       */\r\n      calculateStatisticsForGroup(group) {\r\n          const { settings, allocations } = group;\r\n          \r\n          // 获取该组的最大时间步\r\n          const maxTimestep = this.getMaxTimestepForGroup(allocations);\r\n          const stepStatistics = [];\r\n\r\n          // 为每个时间步计算统计\r\n          for (let step = 0; step <= maxTimestep; step++) {\r\n              const stepStats = this.calculateStepStatisticsForGroup(allocations, step, settings);\r\n              stepStatistics.push(stepStats);\r\n          }\r\n\r\n          return {\r\n              settings: { ...settings },\r\n              stepStatistics,\r\n              summary: this.calculateGroupSummary(stepStatistics, allocations)\r\n          };\r\n      }\r\n\r\n      /**\r\n       * 计算全局摘要信息\r\n       * @returns {Object} 全局摘要\r\n       */\r\n      calculateGlobalSummary() {\r\n          if (!this.statisticsBySettings.length) return {};\r\n          \r\n          // 计算所有配置组的峰值内存使用\r\n          const maxMemoryUsage = Math.max(\r\n              ...this.statisticsBySettings.map(group => \r\n                  Math.max(...group.stepStatistics.map(step => step.usedMemory))\r\n              )\r\n          );\r\n          \r\n          // 计算所有配置组的总分配数\r\n          const totalAllocations = this.statisticsBySettings.reduce(\r\n              (sum, group) => sum + group.summary.totalAllocations, 0\r\n          );\r\n          \r\n          // 计算所有配置组的平均成功率\r\n          const successRates = this.statisticsBySettings.map(group => group.summary.successRate);\r\n          const avgSuccessRate = successRates.reduce((sum, rate) => sum + rate, 0) / successRates.length;\r\n          \r\n          return {\r\n              totalGroups: this.statisticsBySettings.length,\r\n              maxMemoryUsage,\r\n              totalAllocations,\r\n              avgSuccessRate,\r\n              // 可以添加更多全局指标\r\n          };\r\n      }\r\n\r\n      /**\r\n       * 获取所有组的统计结果（使用缓存）\r\n       * @returns {Array}\r\n       */\r\n      getStatistics() {\r\n          if (!this.summaryCache) this.calculateAllStatistics();\r\n          return this.statisticsBySettings;\r\n      }\r\n\r\n      /**\r\n       * 按settings键获取特定组的统计（使用缓存）\r\n       * @param {string} settingsKey - settings的唯一标识键\r\n       * @returns {Object|null}\r\n       */\r\n      getStatisticsBySettings(settingsKey) {\r\n          if (!this.summaryCache) this.calculateAllStatistics();\r\n          return this.statisticsBySettings.find(group => \r\n              this.getSettingsKey(group.settings) === settingsKey\r\n          ) || null;\r\n      }\r\n\r\n      /**\r\n       * 获取所有settings的对比摘要（使用缓存）\r\n       * @returns {Array}\r\n       */\r\n      getSettingsComparison() {\r\n          if (!this.summaryCache) this.calculateAllStatistics();\r\n          return this.statisticsBySettings.map(group => ({\r\n              settings: group.settings,\r\n              settingsKey: this.getSettingsKey(group.settings),\r\n              summary: group.summary\r\n          }));\r\n      }\r\n\r\n      /**\r\n       * 获取全局摘要（使用缓存）\r\n       * @returns {Object}\r\n       */\r\n      getGlobalSummary() {\r\n          if (!this.summaryCache) this.calculateAllStatistics();\r\n          return this.summaryCache.globalSummary;\r\n      }\r\n\r\n      /**\r\n       * 创建空缓存对象\r\n       * @private\r\n       */\r\n      _createEmptyCache() {\r\n          this.summaryCache = {\r\n              groups: [],\r\n              globalSummary: {}\r\n          };\r\n          return this.summaryCache;\r\n      }\r\n      /**\r\n       * 获取单个组的最大时间步\r\n       * @param {Array} allocations - 分配数组\r\n       * @returns {number}\r\n       */\r\n      getMaxTimestepForGroup(allocations) {\r\n          return allocations.reduce((max, alloc) => \r\n              Math.max(max, alloc.timestep_end || 0, alloc.max_timestep || 0), 0\r\n          );\r\n      }\r\n\r\n      /**\r\n       * 计算单个时间步的统计（针对特定settings组）\r\n       * @param {Array} allocations - 分配数组\r\n       * @param {number} step - 时间步\r\n       * @param {Object} settings - 配置信息\r\n       * @returns {Object} 时间步内存统计\r\n       */\r\n      calculateStepStatisticsForGroup(allocations, step, settings) {\r\n          // 获取当前时间步的所有分配\r\n          const stepAllocations = this.getAllocationsForTimestep(allocations, step);\r\n          \r\n          // 按bank分组分配\r\n          const allocationsByBank = this.groupAllocationsByBank(stepAllocations);\r\n\r\n          return {\r\n              step: step,\r\n              settingsKey: this.getSettingsKey(settings),\r\n              totalMemory: this.calculateTotalMemory(stepAllocations),\r\n              usedMemory: this.calculateUsedMemory(stepAllocations),\r\n              freeMemory: this.calculateFreeMemory(stepAllocations),\r\n              memoryUsagePercentage: this.calculateUsagePercentage(stepAllocations),\r\n              peakMemory: this.calculatePeakMemory(stepAllocations),\r\n              allocationCount: stepAllocations.length,\r\n              activeAllocations: stepAllocations.length,\r\n              bankStatistics: this.calculateBankStatistics(allocationsByBank),\r\n              detailedStats: this.getDetailedStatistics(stepAllocations)\r\n          };\r\n      }\r\n\r\n      /**\r\n       * 生成settings的唯一标识键\r\n       * @param {Object} settings - 配置信息\r\n       * @returns {string}\r\n       */\r\n      getSettingsKey(settings) {\r\n          return JSON.stringify({\r\n              allow_bank_conflict: settings.allow_bank_conflict,\r\n              shape_secs: settings.shape_secs\r\n          });\r\n      }\r\n\r\n      /**\r\n       * 获取指定时间步的所有内存分配\r\n       * @param {Array} allocations - 分配数组\r\n       * @param {number} step - 时间步\r\n       * @returns {Array} 该时间步的分配数组\r\n       */\r\n      getAllocationsForTimestep(allocations, step) {\r\n          return allocations.filter(alloc => \r\n              this.isAllocationActive(alloc, step)\r\n          );\r\n      }\r\n\r\n      /**\r\n       * 检查分配是否在指定时间步活跃\r\n       * @param {Object} allocation - 内存分配对象\r\n       * @param {number} step - 时间步\r\n       * @returns {boolean}\r\n       */\r\n      isAllocationActive(allocation, step) {\r\n          if(allocation.hold_in_lmem){\r\n              return true;\r\n          }\r\n          else if( allocation.timestep_start <= allocation.timestep_end){\r\n              return allocation.timestep_start <= step && \r\n                     allocation.timestep_end >= step;\r\n          }\r\n          else {\r\n              return allocation.timestep_start <= step && this.tsCounts >= step \r\n                  ||\r\n                    allocation.timestep_end >= step && 0 <= step;\r\n          }\r\n          // return allocation.timestep_start <= step && \r\n          //        allocation.timestep_end >= step;\r\n      }\r\n\r\n      /**\r\n       * 按bank分组分配\r\n       * @param {Array} allocations - 分配数组\r\n       * @returns {Object} 按bank分组的分配\r\n       */\r\n      groupAllocationsByBank(allocations) {\r\n          return allocations.reduce((groups, alloc) => {\r\n              const bankId = alloc.bank_id || 0;\r\n              if (!groups[bankId]) {\r\n                  groups[bankId] = [];\r\n              }\r\n              groups[bankId].push(alloc);\r\n              return groups;\r\n          }, {});\r\n      }\r\n\r\n      /**\r\n       * 计算bank级别的统计\r\n       * @param {Object} allocationsByBank - 按bank分组的分配\r\n       * @returns {Object} bank统计信息\r\n       */\r\n      calculateBankStatistics(allocationsByBank) {\r\n          const bankStats = {};\r\n          \r\n          for (const [bankId, allocations] of Object.entries(allocationsByBank)) {\r\n              bankStats[bankId] = {\r\n                  usedMemory: this.calculateUsedMemory(allocations),\r\n                  allocationCount: allocations.length,\r\n                  averageAllocationSize: this.calculateAverageAllocation(allocations),\r\n                  largestAllocation: this.calculateLargestAllocation(allocations)\r\n              };\r\n          }\r\n          \r\n          return bankStats;\r\n      }\r\n\r\n      /**\r\n       * 计算总内存（基于最大地址）\r\n       * @param {Array} allocations - 分配数组\r\n       * @returns {number}\r\n       */\r\n      calculateTotalMemory(allocations) {\r\n          if (allocations.length === 0) return 0;\r\n          \r\n          // 找到最大的结束地址\r\n          const maxAddr = Math.max(...allocations.map(alloc => alloc.addr + alloc.size));\r\n          return maxAddr;\r\n      }\r\n\r\n      /**\r\n       * 计算已使用内存\r\n       * @param {Array} allocations - 分配数组\r\n       * @returns {number}\r\n       */\r\n      calculateUsedMemory(allocations) {\r\n          return allocations.reduce((total, alloc) => total + alloc.size, 0);\r\n      }\r\n\r\n      /**\r\n       * 计算空闲内存\r\n       * @param {Array} allocations - 分配数组\r\n       * @returns {number}\r\n       */\r\n      calculateFreeMemory(allocations) {\r\n          const total = this.calculateTotalMemory(allocations);\r\n          const used = this.calculateUsedMemory(allocations);\r\n          return Math.max(0, total - used);\r\n      }\r\n\r\n      /**\r\n       * 计算内存使用率\r\n       * @param {Array} allocations - 分配数组\r\n       * @returns {number}\r\n       */\r\n      calculateUsagePercentage(allocations) {\r\n          const total = this.calculateTotalMemory(allocations);\r\n          const used = this.calculateUsedMemory(allocations);\r\n          return total > 0 ? (used / total) * 100 : 0;\r\n      }\r\n\r\n      /**\r\n       * 计算峰值内存（当前时间步最大单分配）\r\n       * @param {Array} allocations - 分配数组\r\n       * @returns {number}\r\n       */\r\n      calculatePeakMemory(allocations) {\r\n          return allocations.length > 0 ? \r\n              Math.max(...allocations.map(alloc => alloc.size)) : 0;\r\n      }\r\n\r\n      /**\r\n       * 计算平均分配大小\r\n       * @param {Array} allocations - 分配数组\r\n       * @returns {number}\r\n       */\r\n      calculateAverageAllocation(allocations) {\r\n          const used = this.calculateUsedMemory(allocations);\r\n          return allocations.length > 0 ? used / allocations.length : 0;\r\n      }\r\n\r\n      /**\r\n       * 计算最大分配大小\r\n       * @param {Array} allocations - 分配数组\r\n       * @returns {number}\r\n       */\r\n      calculateLargestAllocation(allocations) {\r\n          return allocations.length > 0 ? \r\n              Math.max(...allocations.map(alloc => alloc.size)) : 0;\r\n      }\r\n\r\n      /**\r\n       * 获取详细统计信息\r\n       * @param {Array} allocations - 分配数组\r\n       * @returns {Object}\r\n       */\r\n      getDetailedStatistics(allocations) {\r\n          const successfulAllocs = allocations.filter(alloc => alloc.status === 'success');\r\n          const failedAllocs = allocations.filter(alloc => alloc.status !== 'success');\r\n\r\n          return {\r\n              successfulAllocations: successfulAllocs.length,\r\n              failedAllocations: failedAllocs.length,\r\n              successRate: allocations.length > 0 ? \r\n                  (successfulAllocs.length / allocations.length) * 100 : 0,\r\n              averageAllocationSize: this.calculateAverageAllocation(allocations),\r\n              memoryFragmentation: this.calculateFragmentation(allocations),\r\n              allocationTypes: this.countAllocationTypes(allocations)\r\n          };\r\n      }\r\n\r\n      /**\r\n       * 计算内存碎片率\r\n       * @param {Array} allocations - 分配数组\r\n       * @returns {number}\r\n       */\r\n      calculateFragmentation(allocations) {\r\n          if (allocations.length < 2) return 0;\r\n          \r\n          const sortedAllocs = [...allocations].sort((a, b) => a.addr - b.addr);\r\n          let totalGap = 0;\r\n          \r\n          for (let i = 1; i < sortedAllocs.length; i++) {\r\n              const prevEnd = sortedAllocs[i-1].addr + sortedAllocs[i-1].size;\r\n              const gap = sortedAllocs[i].addr - prevEnd;\r\n              totalGap += Math.max(0, gap);\r\n          }\r\n          \r\n          const totalMemory = this.calculateTotalMemory(allocations);\r\n          return totalMemory > 0 ? (totalGap / totalMemory) * 100 : 0;\r\n      }\r\n\r\n      /**\r\n       * 统计分配类型\r\n       * @param {Array} allocations - 分配数组\r\n       * @returns {Object}\r\n       */\r\n      countAllocationTypes(allocations) {\r\n          return allocations.reduce((counts, alloc) => {\r\n              const type = alloc.lmem_type || 'unknown';\r\n              counts[type] = (counts[type] || 0) + 1;\r\n              return counts;\r\n          }, {});\r\n      }\r\n\r\n      /**\r\n       * 计算组的统计摘要\r\n       * @param {Array} stepStatistics - 时间步统计数组\r\n       * @param {Array} allocations - 分配数组\r\n       * @returns {Object}\r\n       */\r\n      calculateGroupSummary(stepStatistics, allocations) {\r\n          const successfulAllocs = allocations.filter(alloc => alloc.status === 'success');\r\n          const failedAllocs = allocations.filter(alloc => alloc.status !== 'success');\r\n\r\n          return {\r\n              totalAllocations: allocations.length,\r\n              successfulAllocations: successfulAllocs.length,\r\n              failedAllocations: failedAllocs.length,\r\n              successRate: allocations.length > 0 ? \r\n                  (successfulAllocs.length / allocations.length) * 100 : 0,\r\n              maxMemoryUsage: Math.max(...stepStatistics.map(stat => stat.usedMemory)),\r\n              averageMemoryUsage: stepStatistics.reduce((sum, stat) => sum + stat.usedMemory, 0) / stepStatistics.length,\r\n              peakAllocationCount: Math.max(...stepStatistics.map(stat => stat.allocationCount)),\r\n              totalMemoryFootprint: this.calculateTotalMemory(allocations)\r\n          };\r\n      }\r\n\r\n      /**\r\n       * 获取所有组的统计结果\r\n       * @returns {Array}\r\n       */\r\n      getStatistics() {\r\n          return this.statisticsBySettings;\r\n      }\r\n\r\n      /**\r\n       * 按settings键获取特定组的统计\r\n       * @param {string} settingsKey - settings的唯一标识键\r\n       * @returns {Object|null}\r\n       */\r\n      getStatisticsBySettings(settingsKey) {\r\n          return this.statisticsBySettings.find(group => \r\n              this.getSettingsKey(group.settings) === settingsKey\r\n          ) || null;\r\n      }\r\n\r\n      /**\r\n       * 获取所有settings的对比摘要\r\n       * @returns {Array}\r\n       */\r\n      getSettingsComparison() {\r\n          return this.statisticsBySettings.map(group => ({\r\n              settings: group.settings,\r\n              settingsKey: this.getSettingsKey(group.settings),\r\n              summary: group.summary\r\n          }));\r\n      }\r\n\r\n      /**\r\n       * 清空数据\r\n       */\r\n      clear() {\r\n          this.lmemGroups = [];\r\n          this.statisticsBySettings = [];\r\n          this.summaryCache = null;   // 清除缓存\r\n      }\r\n  }\n\n  self.onmessage = async (e) => {\r\n    const rawLog = e.data;\r\n    try {\r\n      // 输入验证\r\n      if (!rawLog || typeof rawLog !== 'string') {\r\n        throw new Error('Invalid input: rawLog must be a non-empty string');\r\n      }\r\n\r\n      // 提取有效段（分离LMEM和Timestep）\r\n      const { lmemSections, timestepSections, chip } = extractValidSections(rawLog);\r\n      \r\n      // 独立解析结果对象\r\n      const results = {\r\n        lmem: null,\r\n        summary: null,\r\n        timestep: null,\r\n        chip: chip || null\r\n      };\r\n      \r\n      // 独立有效性标志\r\n      const valid = {\r\n        lmem: false,\r\n        summary: false,\r\n        timestep: false\r\n      };\r\n\r\n      // 1. 独立解析LMEM数据\r\n      if (lmemSections.length) {\r\n        try {\r\n          const lmemParser = new LmemParser();\r\n          results.lmem = lmemParser.parse(lmemSections);\r\n          valid.lmem = true;\r\n          \r\n          // 2. 独立计算Summary\r\n          if (results.lmem.length) {\r\n            const memoryStats = new MemoryStatistics();\r\n            memoryStats.setLmemData(results.lmem, lmemParser.getGlobalMaxTimestep());\r\n            const summaryCache = memoryStats.calculateAllStatistics();\r\n            results.summary = summaryCache;\r\n            valid.summary = true;\r\n            \r\n            // 将芯片信息合并到第一个settings组\r\n            if (chip) {\r\n              Object.assign(results.lmem[0].settings, chip);\r\n            }\r\n          }\r\n        } catch (lmemErr) {\r\n          console.error('[Worker] LMEM解析错误:', lmemErr);\r\n        }\r\n      }\r\n\r\n      // 3. 独立解析Timestep数据\r\n      if (timestepSections.length) {\r\n        try {\r\n          const timestepParser = new TimestepParser();\r\n          results.timestep = timestepParser.parse(timestepSections);\r\n          valid.timestep = true;\r\n        } catch (timestepErr) {\r\n          console.error('[Worker] Timestep解析错误:', timestepErr);\r\n        }\r\n      }\r\n\r\n      // 检查至少有一个有效部分\r\n      if (!valid.lmem && !valid.timestep) {\r\n        throw new Error('No valid data sections found in the log file');\r\n      }\r\n\r\n      // 返回结果和有效性状态\r\n      self.postMessage({\r\n        ...results,\r\n        valid,\r\n        success: true\r\n      });\r\n      \r\n    } catch (err) {\r\n      console.error('[Worker]', err);\r\n      self.postMessage({ \r\n        error: err.message,\r\n        success: false\r\n      });\r\n    }\r\n  };\n\n})();\n"], { type: 'application/javascript' })));



worker.onmessage = (e) => {
  const { success, error, valid, ...data } = e.data;
  
  if (!success) {
    statusMessage.value = `❌ ${error || '解析失败'}`;
    return;
  }
  
  // 根据有效部分更新状态
  const statusParts = [];
  if (valid.lmem) statusParts.push('LMEM');
  if (valid.summary) statusParts.push('Summary');
  if (valid.timestep) statusParts.push('Timestep');
  
  label.value = '✅ 解析完成';
  statusMessage.value = `有效数据: ${statusParts.join(', ') || '无'}`;
  
  // 发送解析结果
  emit('file-loaded', { 
    ...data,
    valid
  });
};

async function onChange(e) {
  const file = e.target.files[0];
  if (!file) return;

  label.value = '⏳ 解析中...';
  statusMessage.value = '';
  
  try {
    const text = await file.text();
    worker.postMessage(text);
  } catch (err) {
    console.error(err);
    label.value = '📁 选择日志';
    statusMessage.value = '❌ 文件读取失败';
  }
}
</script>

<style scoped>
.file-selector {
  cursor: pointer;
  display: inline-flex;
  flex-direction: column;
  padding: 12px;
  border: 1px solid #ccc;
  border-radius: 8px;
  background: #f8f9fa;
  font-size: 14px;
  min-width: 80px;
}

.file-selector input[type="file"] {
  display: none;
}

.status {
  margin-top: 4px;
  font-size: 8px;
  color: #666;
}
</style>