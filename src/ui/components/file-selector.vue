<template>
  <label class="file-selector">
    <input type="file" accept=".log" @change="onChange" />
    <span>{{ label }}</span>
    <div v-if="statusMessage" class="status">{{ statusMessage }}</div>
  </label>
</template>

<script setup>
import { ref } from 'vue';

const label = ref('ğŸ“ é€‰æ‹©æ—¥å¿—');
const statusMessage = ref('');

const emit = defineEmits(['file-loaded']);

// å®ä¾‹åŒ– Worker
const worker = new Worker(URL.createObjectURL(new Blob(["(function () {\n  'use strict';\n\n  /**\r\n   * ä»åŸå§‹æ—¥å¿—ä¸­æå–æœ‰æ•ˆæ®µè½\r\n   * @param {string} rawLog åŸå§‹æ—¥å¿—æ–‡æœ¬\r\n   * @returns {{\r\n   *   lmemSections: string[],\r\n   *   timestepSections: string[],\r\n   *   chip: Object\r\n   * }}\r\n   */\r\n  function extractValidSections(rawLog) {\r\n    const sections = rawLog.split(/(?=; action = \\w+)/g);\r\n\r\n    /* 1. èŠ¯ç‰‡è§„æ ¼æ®µè½ï¼ˆåªå–ç¬¬ä¸€æ¡ï¼‰ */\r\n    const chipSection = sections.find(sec =>\r\n      sec.includes('; action = lmem_assign') && sec.includes('; step = lmem_spec')\r\n    );\r\n\r\n    /* 2. è§£æèŠ¯ç‰‡å­—æ®µ */\r\n    const chip = {};\r\n    if (chipSection) {\r\n      const regex = /;\\s*(\\w+)\\s*=\\s*([^;]+)/gi;\r\n      let m;\r\n      while ((m = regex.exec(chipSection)) !== null) {\r\n        const [, key, val] = m;\r\n        if (['lmem_bytes', 'lmem_banks', 'lmem_bank_bytes'].includes(key)) {\r\n          chip[key] = Number(val.trim());\r\n        }\r\n      }\r\n      console.log('[extractValidSections] èŠ¯ç‰‡ä¿¡æ¯:', chip);\r\n    }\r\n\r\n    /* 3. lmem_assign + iteration_result æ®µè½ï¼ˆä¸å«èŠ¯ç‰‡æ®µè½ï¼‰ */\r\n    const lmemSections = sections.filter(\r\n      sec =>\r\n        sec.includes('; action = lmem_assign') &&\r\n        sec.includes('; tag = iteration_result') &&\r\n        !sec.includes('; step = lmem_spec')\r\n    );\r\n\r\n    /* 4. timestep  */\r\n    const timestepSections = sections\r\n      .filter(\r\n        sec =>\r\n          sec.includes('; action = timestep_assign') &&\r\n          sec.includes('; tag = final_result')\r\n      )\r\n      .slice(-1);  // åªå–æœ€åä¸€ä¸ª\r\n\r\n    return { lmemSections, timestepSections, chip };\r\n  }\n\n  class LmemParser {\r\n    static FIELDS_WHITELIST = new Set([\r\n      'op_name',\r\n      'op_type',\r\n      'addr',\r\n      'size',\r\n      'timestep_start',\r\n      'timestep_end',\r\n      'lmem_type',\r\n      'hold_in_lmem',\r\n      //'allow_bank_conflict',\r\n      //'one_loop',\r\n      //'shape_secs',\r\n      'status',\r\n      'tag',\r\n      'bank_id',\r\n    ]);\r\n    constructor() {\r\n      this.maxTimestepGlobal = 0;\r\n    }\r\n\r\n  getGlobalMaxTimestep() {\r\n    return this.maxTimestepGlobal;\r\n  }\r\n\r\n    /**\r\n     * è§£æå¹¶å¤„ç†LMEMåˆ†é…æ•°æ®\r\n     * @param {string[]} lmemSections é¢„å¤„ç†åçš„ LMEM æ—¥å¿—æ®µè½æ•°ç»„\r\n     * @returns {{settings: Object, allocations: LmemAllocation[]}[]}\r\n     */\r\n    parse(lmemSections) {\r\n      const rawGroups = this._groupBySettings(lmemSections);\r\n      return this._processAllocationGroups(rawGroups);\r\n    }\r\n\r\n    // æŒ‰é…ç½®åˆ†ç»„åŸå§‹æ•°æ®\r\n    _groupBySettings(sections) {\r\n      const groups = [];\r\n      let currentGroup = null;\r\n\r\n      sections.forEach(section => {\r\n        const { entry, settings } = this._parseSection(section);\r\n        if(!entry) return;\r\n\r\n        // æ–°é…ç½®ç»„æ£€æµ‹\r\n        if (!currentGroup || !this._isSameSettings(currentGroup.settings, settings)) {\r\n          currentGroup = { settings, allocations: [] };\r\n          groups.push(currentGroup);\r\n        }\r\n\r\n        currentGroup.allocations.push(entry);\r\n      });\r\n\r\n      return groups;\r\n    }\r\n\r\n    // è§£æå•ä¸ªæ—¥å¿—æ®µè½\r\n    _parseSection(section) {\r\n      const entry = {};\r\n      const settings = {};\r\n      const fieldRegex = /; (\\w+) = ([^;]+)/g;\r\n      //const fieldRegex = /;\\s*(\\w+)\\s*=\\s*([^;]+)/gi;\r\n\r\n      let match;\r\n      while ((match = fieldRegex.exec(section)) !== null) {\r\n        const [_, key, rawValue] = match;\r\n        const value = this._convertValue(key, rawValue.trim());\r\n        \r\n\r\n        if (key === 'shape_secs' || key === 'allow_bank_conflict') {\r\n          settings[key] = value;\r\n        }\r\n\r\n        if (this.constructor.FIELDS_WHITELIST.has(key)) {\r\n          entry[key] = value;\r\n        }\r\n      }\r\n\r\n      return {\r\n        entry: this._validateEntry(entry),\r\n        settings\r\n      };\r\n    }\r\n\r\n    // å¤„ç†åˆ†ç»„æ•°æ®ï¼ˆåŒ…å«å¤±è´¥åˆ†é…çš„é‡å®šä½ï¼‰\r\n    _processAllocationGroups(groups) {\r\n      return groups.map(group => {\r\n        const { settings, allocations } = group;\r\n        const { success, failed } = this._splitByStatus(allocations);\r\n\r\n        // è®¡ç®—æˆåŠŸåˆ†é…çš„æœ€å¤§åœ°å€\r\n        const maxAddr = success.reduce((max, alloc) => \r\n          Math.max(max, alloc.addr + alloc.size), 0);\r\n\r\n        // é‡å®šä½å¤±è´¥åˆ†é…\r\n        let currentAddr = maxAddr;\r\n        const relocated = failed.map(alloc => {\r\n          const newAlloc = { ...alloc, addr: currentAddr };\r\n          currentAddr += alloc.size;\r\n          return newAlloc;\r\n        });\r\n\r\n        // è®¡ç®—æœ€å¤§æ—¶é—´æ­¥\r\n        const maxTimestep = Math.max(\r\n          ...success.map(a => a.timestep_end),\r\n          ...failed.map(a => a.timestep_end)\r\n        );\r\n        // æ›´æ–°å…¨å±€æœ€å¤§æ—¶é—´æ­¥è®°å½•\r\n        this.maxTimestepGlobal = Math.max(this.maxTimestepGlobal, maxTimestep);\r\n\r\n        return {\r\n          settings,\r\n          allocations: [\r\n            ...success,\r\n            ...relocated\r\n          ].map(alloc => ({\r\n            ...alloc,\r\n            bank_id: (alloc.addr >> 16) & 0xF,\r\n            max_timestep: maxTimestep\r\n          }))\r\n        };\r\n      });\r\n    }\r\n\r\n    // æŒ‰çŠ¶æ€åˆ†ç±»\r\n    _splitByStatus(allocations) {\r\n      return allocations.reduce((acc, alloc) => {\r\n        if (alloc.status === 'success') {\r\n          acc.success.push(alloc);\r\n        } else {\r\n          acc.failed.push(alloc);\r\n        }\r\n        return acc;\r\n      }, { success: [], failed: [] });\r\n    }\r\n\r\n    // é…ç½®æ¯”è¾ƒ\r\n    _isSameSettings(a, b) {\r\n      return ['shape_secs', 'allow_bank_conflict'].every(\r\n        key => JSON.stringify(a[key]) === JSON.stringify(b[key])\r\n      );\r\n    }\r\n\r\n    _convertValue(key, value) {\r\n      value = value.trim();   // â† å…ˆå»æ‰é¦–å°¾ç©ºæ ¼ã€æ¢è¡Œ\r\n      // å¸ƒå°”å‹å­—æ®µ\r\n      if (['hold_in_lmem', 'allow_bank_conflict', 'one_loop'].includes(key)) {\r\n        return value === '1' || value.toLowerCase() === 'true';\r\n      }\r\n      \r\n      // æ•°å€¼å‹å­—æ®µ\r\n      if (value.startsWith('0x')) return parseInt(value, 16);\r\n      if (!isNaN(value)) return Number(value);\r\n      \r\n      // æ•°ç»„å‹å­—æ®µ\r\n      if (key === 'shape_secs') return value.split(',').map(Number);\r\n      \r\n      // å­—ç¬¦ä¸²å­—æ®µï¼ˆå»é™¤å¼•å·ï¼‰\r\n      return value.startsWith('\"') && value.endsWith('\"') \r\n        ? value.slice(1, -1) \r\n        : value;\r\n    }\r\n\r\n    _validateEntry(entry) {\r\n      if(entry.tag === 'stamp') return null;\r\n\r\n      const requiredFields = [\r\n        'op_name', 'addr', 'size',\r\n        'timestep_start', 'timestep_end',\r\n        'status', 'tag'\r\n      ];\r\n      \r\n      return requiredFields.every(field => field in entry) &&\r\n             entry.tag === 'iteration_result'\r\n        ? entry\r\n        : null;\r\n    }\r\n  }\n\n  class TimestepParser {\r\n    /**\r\n     * @param {string[]} timestepSections é¢„å¤„ç†åçš„Timestepæ®µè½\r\n     * @returns {TimestepAssignment[]}\r\n     */\r\n    parse(timestepSections) {\r\n      if (timestepSections.length === 0) return [];\r\n      \r\n      const section = timestepSections[0];\r\n      const lines = section.split('\\n')\r\n        .filter(line => line.includes('; ts ='));\r\n      \r\n      return lines.map(line => {\r\n        try {\r\n          return this._parseTimestepLine(line);\r\n        } catch (e) {\r\n          console.warn('è§£ætimestepè¡Œå¤±è´¥:', e.message);\r\n          return null;\r\n        }\r\n      }).filter(Boolean);\r\n    }\r\n\r\n    _parseTimestepLine(line) {\r\n      const tsMatch = line.match(/; ts = (\\d+);/);\r\n      if (!tsMatch) throw new Error('æ— æ•ˆçš„æ—¶é—´æ­¥æ ¼å¼');\r\n      \r\n      return {\r\n        ts: parseInt(tsMatch[1]),\r\n        compute: this._extractOperations(line, 'C'), // è®¡ç®—æ“ä½œ\r\n        loads: this._extractOperations(line, 'L'),   // åŠ è½½æ“ä½œ\r\n        stores: this._extractOperations(line, 'S')   // å­˜å‚¨æ“ä½œ\r\n      };\r\n    }\r\n\r\n    _extractOperations(line, type) {\r\n      if (type === 'C') {\r\n        // æ•è·ä¸¤ä¸ªæ‹¬å·é‡Œçš„å­—ç¬¦ä¸²ï¼šC(\"...\") å’Œ \"...\"\r\n        const regex = /C\\(\"([^\"]+)\"\\)[^\"]*\"([^\"]+)\"/g;\r\n        return [...line.matchAll(regex)].map(([_, id1, id2]) => ({\r\n          id: `${id2}`,   // åˆå¹¶è®°å½• `${id1} (${id2})`\r\n          type: 'compute',\r\n          operation: `${id1}`\r\n        }));\r\n      }\r\n      // type ä¸º Læˆ–S\r\n      const regex = new RegExp(`${type}\\\\(\"([^\"]+)\", hold_in_lmem = (\\\\d)\\\\)->([^,\\\\]]+)`, 'g');\r\n      return [...line.matchAll(regex)].map(([_, id, hold, target]) => ({\r\n        id,\r\n        hold_in_lmem: parseInt(hold),\r\n        target,\r\n        type: type === 'C' ? 'compute' : type.toLowerCase()\r\n      }));\r\n    }\r\n  }\n\n  class MemoryStatistics {\r\n      constructor() {\r\n          this.lmemGroups = [];\r\n          this.statisticsBySettings = [];\r\n          this.summaryCache = null;\r\n          this.tsCounts = 0;\r\n      }\r\n\r\n      /**\r\n       * è®¾ç½®LMEMåˆ†ç»„æ•°æ®\r\n       * @param {Array} lmemGroups - LmemParserè§£æåçš„åˆ†ç»„æ•°æ®\r\n       */\r\n      setLmemData(lmemGroups, tsCounts) {\r\n          this.lmemGroups = lmemGroups;\r\n          this.tsCounts = tsCounts;\r\n          // console.log('[MemoryStatistics] è®¾ç½®LMEMæ•°æ®ï¼Œæ—¶é—´æ­¥æ€»æ•°:', this.tsCounts);\r\n          this.summaryCache = null; // æ¸…é™¤ç¼“å­˜\r\n      }\r\n\r\n      /**\r\n       * é¢„è®¡ç®—æ‰€æœ‰é…ç½®ç»„çš„å†…å­˜ç»Ÿè®¡\r\n       * @returns {Object} åŒ…å«æ‰€æœ‰é…ç½®ç»„ç»Ÿè®¡å’Œå…¨å±€æ‘˜è¦çš„ç¼“å­˜å¯¹è±¡\r\n       */\r\n      calculateAllStatistics() {\r\n          // å¦‚æœç¼“å­˜å­˜åœ¨åˆ™ç›´æ¥è¿”å›\r\n          if (this.summaryCache) {\r\n              return this.summaryCache;\r\n          }\r\n          \r\n          this.statisticsBySettings = [];\r\n          \r\n          if (!this.lmemGroups.length) {\r\n              console.warn('ç¼ºå°‘LMEMæ•°æ®');\r\n              return this._createEmptyCache();\r\n          }\r\n\r\n          // ä¸ºæ¯ä¸ªsettingsç»„åˆ†åˆ«è®¡ç®—ç»Ÿè®¡\r\n          for (const group of this.lmemGroups) {\r\n              const groupStats = this.calculateStatisticsForGroup(group);\r\n              this.statisticsBySettings.push(groupStats);\r\n          }\r\n          \r\n          // åˆ›å»ºå¹¶è¿”å›ç¼“å­˜å¯¹è±¡\r\n          this.summaryCache = {\r\n              groups: this.statisticsBySettings,\r\n              globalSummary: this.calculateGlobalSummary()\r\n          };\r\n          \r\n          return this.summaryCache;\r\n      }\r\n\r\n      /**\r\n       * ä¸ºå•ä¸ªsettingsç»„è®¡ç®—ç»Ÿè®¡\r\n       * @param {Object} group - åŒ…å«settingså’Œallocationsçš„ç»„\r\n       * @returns {Object} è¯¥ç»„çš„ç»Ÿè®¡ä¿¡æ¯\r\n       */\r\n      calculateStatisticsForGroup(group) {\r\n          const { settings, allocations } = group;\r\n          \r\n          // è·å–è¯¥ç»„çš„æœ€å¤§æ—¶é—´æ­¥\r\n          const maxTimestep = this.getMaxTimestepForGroup(allocations);\r\n          const stepStatistics = [];\r\n\r\n          // ä¸ºæ¯ä¸ªæ—¶é—´æ­¥è®¡ç®—ç»Ÿè®¡\r\n          for (let step = 0; step <= maxTimestep; step++) {\r\n              const stepStats = this.calculateStepStatisticsForGroup(allocations, step, settings);\r\n              stepStatistics.push(stepStats);\r\n          }\r\n\r\n          return {\r\n              settings: { ...settings },\r\n              stepStatistics,\r\n              summary: this.calculateGroupSummary(stepStatistics, allocations)\r\n          };\r\n      }\r\n\r\n      /**\r\n       * è®¡ç®—å…¨å±€æ‘˜è¦ä¿¡æ¯\r\n       * @returns {Object} å…¨å±€æ‘˜è¦\r\n       */\r\n      calculateGlobalSummary() {\r\n          if (!this.statisticsBySettings.length) return {};\r\n          \r\n          // è®¡ç®—æ‰€æœ‰é…ç½®ç»„çš„å³°å€¼å†…å­˜ä½¿ç”¨\r\n          const maxMemoryUsage = Math.max(\r\n              ...this.statisticsBySettings.map(group => \r\n                  Math.max(...group.stepStatistics.map(step => step.usedMemory))\r\n              )\r\n          );\r\n          \r\n          // è®¡ç®—æ‰€æœ‰é…ç½®ç»„çš„æ€»åˆ†é…æ•°\r\n          const totalAllocations = this.statisticsBySettings.reduce(\r\n              (sum, group) => sum + group.summary.totalAllocations, 0\r\n          );\r\n          \r\n          // è®¡ç®—æ‰€æœ‰é…ç½®ç»„çš„å¹³å‡æˆåŠŸç‡\r\n          const successRates = this.statisticsBySettings.map(group => group.summary.successRate);\r\n          const avgSuccessRate = successRates.reduce((sum, rate) => sum + rate, 0) / successRates.length;\r\n          \r\n          return {\r\n              totalGroups: this.statisticsBySettings.length,\r\n              maxMemoryUsage,\r\n              totalAllocations,\r\n              avgSuccessRate,\r\n              // å¯ä»¥æ·»åŠ æ›´å¤šå…¨å±€æŒ‡æ ‡\r\n          };\r\n      }\r\n\r\n      /**\r\n       * è·å–æ‰€æœ‰ç»„çš„ç»Ÿè®¡ç»“æœï¼ˆä½¿ç”¨ç¼“å­˜ï¼‰\r\n       * @returns {Array}\r\n       */\r\n      getStatistics() {\r\n          if (!this.summaryCache) this.calculateAllStatistics();\r\n          return this.statisticsBySettings;\r\n      }\r\n\r\n      /**\r\n       * æŒ‰settingsé”®è·å–ç‰¹å®šç»„çš„ç»Ÿè®¡ï¼ˆä½¿ç”¨ç¼“å­˜ï¼‰\r\n       * @param {string} settingsKey - settingsçš„å”¯ä¸€æ ‡è¯†é”®\r\n       * @returns {Object|null}\r\n       */\r\n      getStatisticsBySettings(settingsKey) {\r\n          if (!this.summaryCache) this.calculateAllStatistics();\r\n          return this.statisticsBySettings.find(group => \r\n              this.getSettingsKey(group.settings) === settingsKey\r\n          ) || null;\r\n      }\r\n\r\n      /**\r\n       * è·å–æ‰€æœ‰settingsçš„å¯¹æ¯”æ‘˜è¦ï¼ˆä½¿ç”¨ç¼“å­˜ï¼‰\r\n       * @returns {Array}\r\n       */\r\n      getSettingsComparison() {\r\n          if (!this.summaryCache) this.calculateAllStatistics();\r\n          return this.statisticsBySettings.map(group => ({\r\n              settings: group.settings,\r\n              settingsKey: this.getSettingsKey(group.settings),\r\n              summary: group.summary\r\n          }));\r\n      }\r\n\r\n      /**\r\n       * è·å–å…¨å±€æ‘˜è¦ï¼ˆä½¿ç”¨ç¼“å­˜ï¼‰\r\n       * @returns {Object}\r\n       */\r\n      getGlobalSummary() {\r\n          if (!this.summaryCache) this.calculateAllStatistics();\r\n          return this.summaryCache.globalSummary;\r\n      }\r\n\r\n      /**\r\n       * åˆ›å»ºç©ºç¼“å­˜å¯¹è±¡\r\n       * @private\r\n       */\r\n      _createEmptyCache() {\r\n          this.summaryCache = {\r\n              groups: [],\r\n              globalSummary: {}\r\n          };\r\n          return this.summaryCache;\r\n      }\r\n      /**\r\n       * è·å–å•ä¸ªç»„çš„æœ€å¤§æ—¶é—´æ­¥\r\n       * @param {Array} allocations - åˆ†é…æ•°ç»„\r\n       * @returns {number}\r\n       */\r\n      getMaxTimestepForGroup(allocations) {\r\n          return allocations.reduce((max, alloc) => \r\n              Math.max(max, alloc.timestep_end || 0, alloc.max_timestep || 0), 0\r\n          );\r\n      }\r\n\r\n      /**\r\n       * è®¡ç®—å•ä¸ªæ—¶é—´æ­¥çš„ç»Ÿè®¡ï¼ˆé’ˆå¯¹ç‰¹å®šsettingsç»„ï¼‰\r\n       * @param {Array} allocations - åˆ†é…æ•°ç»„\r\n       * @param {number} step - æ—¶é—´æ­¥\r\n       * @param {Object} settings - é…ç½®ä¿¡æ¯\r\n       * @returns {Object} æ—¶é—´æ­¥å†…å­˜ç»Ÿè®¡\r\n       */\r\n      calculateStepStatisticsForGroup(allocations, step, settings) {\r\n          // è·å–å½“å‰æ—¶é—´æ­¥çš„æ‰€æœ‰åˆ†é…\r\n          const stepAllocations = this.getAllocationsForTimestep(allocations, step);\r\n          \r\n          // æŒ‰bankåˆ†ç»„åˆ†é…\r\n          const allocationsByBank = this.groupAllocationsByBank(stepAllocations);\r\n\r\n          return {\r\n              step: step,\r\n              settingsKey: this.getSettingsKey(settings),\r\n              totalMemory: this.calculateTotalMemory(stepAllocations),\r\n              usedMemory: this.calculateUsedMemory(stepAllocations),\r\n              freeMemory: this.calculateFreeMemory(stepAllocations),\r\n              memoryUsagePercentage: this.calculateUsagePercentage(stepAllocations),\r\n              peakMemory: this.calculatePeakMemory(stepAllocations),\r\n              allocationCount: stepAllocations.length,\r\n              activeAllocations: stepAllocations.length,\r\n              bankStatistics: this.calculateBankStatistics(allocationsByBank),\r\n              detailedStats: this.getDetailedStatistics(stepAllocations)\r\n          };\r\n      }\r\n\r\n      /**\r\n       * ç”Ÿæˆsettingsçš„å”¯ä¸€æ ‡è¯†é”®\r\n       * @param {Object} settings - é…ç½®ä¿¡æ¯\r\n       * @returns {string}\r\n       */\r\n      getSettingsKey(settings) {\r\n          return JSON.stringify({\r\n              allow_bank_conflict: settings.allow_bank_conflict,\r\n              shape_secs: settings.shape_secs\r\n          });\r\n      }\r\n\r\n      /**\r\n       * è·å–æŒ‡å®šæ—¶é—´æ­¥çš„æ‰€æœ‰å†…å­˜åˆ†é…\r\n       * @param {Array} allocations - åˆ†é…æ•°ç»„\r\n       * @param {number} step - æ—¶é—´æ­¥\r\n       * @returns {Array} è¯¥æ—¶é—´æ­¥çš„åˆ†é…æ•°ç»„\r\n       */\r\n      getAllocationsForTimestep(allocations, step) {\r\n          return allocations.filter(alloc => \r\n              this.isAllocationActive(alloc, step)\r\n          );\r\n      }\r\n\r\n      /**\r\n       * æ£€æŸ¥åˆ†é…æ˜¯å¦åœ¨æŒ‡å®šæ—¶é—´æ­¥æ´»è·ƒ\r\n       * @param {Object} allocation - å†…å­˜åˆ†é…å¯¹è±¡\r\n       * @param {number} step - æ—¶é—´æ­¥\r\n       * @returns {boolean}\r\n       */\r\n      isAllocationActive(allocation, step) {\r\n          if(allocation.hold_in_lmem){\r\n              return true;\r\n          }\r\n          else if( allocation.timestep_start <= allocation.timestep_end){\r\n              return allocation.timestep_start <= step && \r\n                     allocation.timestep_end >= step;\r\n          }\r\n          else {\r\n              return allocation.timestep_start <= step && this.tsCounts >= step \r\n                  ||\r\n                    allocation.timestep_end >= step && 0 <= step;\r\n          }\r\n          // return allocation.timestep_start <= step && \r\n          //        allocation.timestep_end >= step;\r\n      }\r\n\r\n      /**\r\n       * æŒ‰bankåˆ†ç»„åˆ†é…\r\n       * @param {Array} allocations - åˆ†é…æ•°ç»„\r\n       * @returns {Object} æŒ‰bankåˆ†ç»„çš„åˆ†é…\r\n       */\r\n      groupAllocationsByBank(allocations) {\r\n          return allocations.reduce((groups, alloc) => {\r\n              const bankId = alloc.bank_id || 0;\r\n              if (!groups[bankId]) {\r\n                  groups[bankId] = [];\r\n              }\r\n              groups[bankId].push(alloc);\r\n              return groups;\r\n          }, {});\r\n      }\r\n\r\n      /**\r\n       * è®¡ç®—bankçº§åˆ«çš„ç»Ÿè®¡\r\n       * @param {Object} allocationsByBank - æŒ‰bankåˆ†ç»„çš„åˆ†é…\r\n       * @returns {Object} bankç»Ÿè®¡ä¿¡æ¯\r\n       */\r\n      calculateBankStatistics(allocationsByBank) {\r\n          const bankStats = {};\r\n          \r\n          for (const [bankId, allocations] of Object.entries(allocationsByBank)) {\r\n              bankStats[bankId] = {\r\n                  usedMemory: this.calculateUsedMemory(allocations),\r\n                  allocationCount: allocations.length,\r\n                  averageAllocationSize: this.calculateAverageAllocation(allocations),\r\n                  largestAllocation: this.calculateLargestAllocation(allocations)\r\n              };\r\n          }\r\n          \r\n          return bankStats;\r\n      }\r\n\r\n      /**\r\n       * è®¡ç®—æ€»å†…å­˜ï¼ˆåŸºäºæœ€å¤§åœ°å€ï¼‰\r\n       * @param {Array} allocations - åˆ†é…æ•°ç»„\r\n       * @returns {number}\r\n       */\r\n      calculateTotalMemory(allocations) {\r\n          if (allocations.length === 0) return 0;\r\n          \r\n          // æ‰¾åˆ°æœ€å¤§çš„ç»“æŸåœ°å€\r\n          const maxAddr = Math.max(...allocations.map(alloc => alloc.addr + alloc.size));\r\n          return maxAddr;\r\n      }\r\n\r\n      /**\r\n       * è®¡ç®—å·²ä½¿ç”¨å†…å­˜\r\n       * @param {Array} allocations - åˆ†é…æ•°ç»„\r\n       * @returns {number}\r\n       */\r\n      calculateUsedMemory(allocations) {\r\n          return allocations.reduce((total, alloc) => total + alloc.size, 0);\r\n      }\r\n\r\n      /**\r\n       * è®¡ç®—ç©ºé—²å†…å­˜\r\n       * @param {Array} allocations - åˆ†é…æ•°ç»„\r\n       * @returns {number}\r\n       */\r\n      calculateFreeMemory(allocations) {\r\n          const total = this.calculateTotalMemory(allocations);\r\n          const used = this.calculateUsedMemory(allocations);\r\n          return Math.max(0, total - used);\r\n      }\r\n\r\n      /**\r\n       * è®¡ç®—å†…å­˜ä½¿ç”¨ç‡\r\n       * @param {Array} allocations - åˆ†é…æ•°ç»„\r\n       * @returns {number}\r\n       */\r\n      calculateUsagePercentage(allocations) {\r\n          const total = this.calculateTotalMemory(allocations);\r\n          const used = this.calculateUsedMemory(allocations);\r\n          return total > 0 ? (used / total) * 100 : 0;\r\n      }\r\n\r\n      /**\r\n       * è®¡ç®—å³°å€¼å†…å­˜ï¼ˆå½“å‰æ—¶é—´æ­¥æœ€å¤§å•åˆ†é…ï¼‰\r\n       * @param {Array} allocations - åˆ†é…æ•°ç»„\r\n       * @returns {number}\r\n       */\r\n      calculatePeakMemory(allocations) {\r\n          return allocations.length > 0 ? \r\n              Math.max(...allocations.map(alloc => alloc.size)) : 0;\r\n      }\r\n\r\n      /**\r\n       * è®¡ç®—å¹³å‡åˆ†é…å¤§å°\r\n       * @param {Array} allocations - åˆ†é…æ•°ç»„\r\n       * @returns {number}\r\n       */\r\n      calculateAverageAllocation(allocations) {\r\n          const used = this.calculateUsedMemory(allocations);\r\n          return allocations.length > 0 ? used / allocations.length : 0;\r\n      }\r\n\r\n      /**\r\n       * è®¡ç®—æœ€å¤§åˆ†é…å¤§å°\r\n       * @param {Array} allocations - åˆ†é…æ•°ç»„\r\n       * @returns {number}\r\n       */\r\n      calculateLargestAllocation(allocations) {\r\n          return allocations.length > 0 ? \r\n              Math.max(...allocations.map(alloc => alloc.size)) : 0;\r\n      }\r\n\r\n      /**\r\n       * è·å–è¯¦ç»†ç»Ÿè®¡ä¿¡æ¯\r\n       * @param {Array} allocations - åˆ†é…æ•°ç»„\r\n       * @returns {Object}\r\n       */\r\n      getDetailedStatistics(allocations) {\r\n          const successfulAllocs = allocations.filter(alloc => alloc.status === 'success');\r\n          const failedAllocs = allocations.filter(alloc => alloc.status !== 'success');\r\n\r\n          return {\r\n              successfulAllocations: successfulAllocs.length,\r\n              failedAllocations: failedAllocs.length,\r\n              successRate: allocations.length > 0 ? \r\n                  (successfulAllocs.length / allocations.length) * 100 : 0,\r\n              averageAllocationSize: this.calculateAverageAllocation(allocations),\r\n              memoryFragmentation: this.calculateFragmentation(allocations),\r\n              allocationTypes: this.countAllocationTypes(allocations)\r\n          };\r\n      }\r\n\r\n      /**\r\n       * è®¡ç®—å†…å­˜ç¢ç‰‡ç‡\r\n       * @param {Array} allocations - åˆ†é…æ•°ç»„\r\n       * @returns {number}\r\n       */\r\n      calculateFragmentation(allocations) {\r\n          if (allocations.length < 2) return 0;\r\n          \r\n          const sortedAllocs = [...allocations].sort((a, b) => a.addr - b.addr);\r\n          let totalGap = 0;\r\n          \r\n          for (let i = 1; i < sortedAllocs.length; i++) {\r\n              const prevEnd = sortedAllocs[i-1].addr + sortedAllocs[i-1].size;\r\n              const gap = sortedAllocs[i].addr - prevEnd;\r\n              totalGap += Math.max(0, gap);\r\n          }\r\n          \r\n          const totalMemory = this.calculateTotalMemory(allocations);\r\n          return totalMemory > 0 ? (totalGap / totalMemory) * 100 : 0;\r\n      }\r\n\r\n      /**\r\n       * ç»Ÿè®¡åˆ†é…ç±»å‹\r\n       * @param {Array} allocations - åˆ†é…æ•°ç»„\r\n       * @returns {Object}\r\n       */\r\n      countAllocationTypes(allocations) {\r\n          return allocations.reduce((counts, alloc) => {\r\n              const type = alloc.lmem_type || 'unknown';\r\n              counts[type] = (counts[type] || 0) + 1;\r\n              return counts;\r\n          }, {});\r\n      }\r\n\r\n      /**\r\n       * è®¡ç®—ç»„çš„ç»Ÿè®¡æ‘˜è¦\r\n       * @param {Array} stepStatistics - æ—¶é—´æ­¥ç»Ÿè®¡æ•°ç»„\r\n       * @param {Array} allocations - åˆ†é…æ•°ç»„\r\n       * @returns {Object}\r\n       */\r\n      calculateGroupSummary(stepStatistics, allocations) {\r\n          const successfulAllocs = allocations.filter(alloc => alloc.status === 'success');\r\n          const failedAllocs = allocations.filter(alloc => alloc.status !== 'success');\r\n\r\n          return {\r\n              totalAllocations: allocations.length,\r\n              successfulAllocations: successfulAllocs.length,\r\n              failedAllocations: failedAllocs.length,\r\n              successRate: allocations.length > 0 ? \r\n                  (successfulAllocs.length / allocations.length) * 100 : 0,\r\n              maxMemoryUsage: Math.max(...stepStatistics.map(stat => stat.usedMemory)),\r\n              averageMemoryUsage: stepStatistics.reduce((sum, stat) => sum + stat.usedMemory, 0) / stepStatistics.length,\r\n              peakAllocationCount: Math.max(...stepStatistics.map(stat => stat.allocationCount)),\r\n              totalMemoryFootprint: this.calculateTotalMemory(allocations)\r\n          };\r\n      }\r\n\r\n      /**\r\n       * è·å–æ‰€æœ‰ç»„çš„ç»Ÿè®¡ç»“æœ\r\n       * @returns {Array}\r\n       */\r\n      getStatistics() {\r\n          return this.statisticsBySettings;\r\n      }\r\n\r\n      /**\r\n       * æŒ‰settingsé”®è·å–ç‰¹å®šç»„çš„ç»Ÿè®¡\r\n       * @param {string} settingsKey - settingsçš„å”¯ä¸€æ ‡è¯†é”®\r\n       * @returns {Object|null}\r\n       */\r\n      getStatisticsBySettings(settingsKey) {\r\n          return this.statisticsBySettings.find(group => \r\n              this.getSettingsKey(group.settings) === settingsKey\r\n          ) || null;\r\n      }\r\n\r\n      /**\r\n       * è·å–æ‰€æœ‰settingsçš„å¯¹æ¯”æ‘˜è¦\r\n       * @returns {Array}\r\n       */\r\n      getSettingsComparison() {\r\n          return this.statisticsBySettings.map(group => ({\r\n              settings: group.settings,\r\n              settingsKey: this.getSettingsKey(group.settings),\r\n              summary: group.summary\r\n          }));\r\n      }\r\n\r\n      /**\r\n       * æ¸…ç©ºæ•°æ®\r\n       */\r\n      clear() {\r\n          this.lmemGroups = [];\r\n          this.statisticsBySettings = [];\r\n          this.summaryCache = null;   // æ¸…é™¤ç¼“å­˜\r\n      }\r\n  }\n\n  self.onmessage = async (e) => {\r\n    const rawLog = e.data;\r\n    try {\r\n      // è¾“å…¥éªŒè¯\r\n      if (!rawLog || typeof rawLog !== 'string') {\r\n        throw new Error('Invalid input: rawLog must be a non-empty string');\r\n      }\r\n\r\n      // æå–æœ‰æ•ˆæ®µï¼ˆåˆ†ç¦»LMEMå’ŒTimestepï¼‰\r\n      const { lmemSections, timestepSections, chip } = extractValidSections(rawLog);\r\n      \r\n      // ç‹¬ç«‹è§£æç»“æœå¯¹è±¡\r\n      const results = {\r\n        lmem: null,\r\n        summary: null,\r\n        timestep: null,\r\n        chip: chip || null\r\n      };\r\n      \r\n      // ç‹¬ç«‹æœ‰æ•ˆæ€§æ ‡å¿—\r\n      const valid = {\r\n        lmem: false,\r\n        summary: false,\r\n        timestep: false\r\n      };\r\n\r\n      // 1. ç‹¬ç«‹è§£æLMEMæ•°æ®\r\n      if (lmemSections.length) {\r\n        try {\r\n          const lmemParser = new LmemParser();\r\n          results.lmem = lmemParser.parse(lmemSections);\r\n          valid.lmem = true;\r\n          \r\n          // 2. ç‹¬ç«‹è®¡ç®—Summary\r\n          if (results.lmem.length) {\r\n            const memoryStats = new MemoryStatistics();\r\n            memoryStats.setLmemData(results.lmem, lmemParser.getGlobalMaxTimestep());\r\n            const summaryCache = memoryStats.calculateAllStatistics();\r\n            results.summary = summaryCache;\r\n            valid.summary = true;\r\n            \r\n            // å°†èŠ¯ç‰‡ä¿¡æ¯åˆå¹¶åˆ°ç¬¬ä¸€ä¸ªsettingsç»„\r\n            if (chip) {\r\n              Object.assign(results.lmem[0].settings, chip);\r\n            }\r\n          }\r\n        } catch (lmemErr) {\r\n          console.error('[Worker] LMEMè§£æé”™è¯¯:', lmemErr);\r\n        }\r\n      }\r\n\r\n      // 3. ç‹¬ç«‹è§£æTimestepæ•°æ®\r\n      if (timestepSections.length) {\r\n        try {\r\n          const timestepParser = new TimestepParser();\r\n          results.timestep = timestepParser.parse(timestepSections);\r\n          valid.timestep = true;\r\n        } catch (timestepErr) {\r\n          console.error('[Worker] Timestepè§£æé”™è¯¯:', timestepErr);\r\n        }\r\n      }\r\n\r\n      // æ£€æŸ¥è‡³å°‘æœ‰ä¸€ä¸ªæœ‰æ•ˆéƒ¨åˆ†\r\n      if (!valid.lmem && !valid.timestep) {\r\n        throw new Error('No valid data sections found in the log file');\r\n      }\r\n\r\n      // è¿”å›ç»“æœå’Œæœ‰æ•ˆæ€§çŠ¶æ€\r\n      self.postMessage({\r\n        ...results,\r\n        valid,\r\n        success: true\r\n      });\r\n      \r\n    } catch (err) {\r\n      console.error('[Worker]', err);\r\n      self.postMessage({ \r\n        error: err.message,\r\n        success: false\r\n      });\r\n    }\r\n  };\n\n})();\n"], { type: 'application/javascript' })));



worker.onmessage = (e) => {
  const { success, error, valid, ...data } = e.data;
  
  if (!success) {
    statusMessage.value = `âŒ ${error || 'è§£æå¤±è´¥'}`;
    return;
  }
  
  // æ ¹æ®æœ‰æ•ˆéƒ¨åˆ†æ›´æ–°çŠ¶æ€
  const statusParts = [];
  if (valid.lmem) statusParts.push('LMEM');
  if (valid.summary) statusParts.push('Summary');
  if (valid.timestep) statusParts.push('Timestep');
  
  label.value = 'âœ… è§£æå®Œæˆ';
  statusMessage.value = `æœ‰æ•ˆæ•°æ®: ${statusParts.join(', ') || 'æ— '}`;
  
  // å‘é€è§£æç»“æœ
  emit('file-loaded', { 
    ...data,
    valid
  });
};

async function onChange(e) {
  const file = e.target.files[0];
  if (!file) return;

  label.value = 'â³ è§£æä¸­...';
  statusMessage.value = '';
  
  try {
    const text = await file.text();
    worker.postMessage(text);
  } catch (err) {
    console.error(err);
    label.value = 'ğŸ“ é€‰æ‹©æ—¥å¿—';
    statusMessage.value = 'âŒ æ–‡ä»¶è¯»å–å¤±è´¥';
  }
}
</script>

<style scoped>
.file-selector {
  cursor: pointer;
  display: inline-flex;
  flex-direction: column;
  padding: 12px;
  border: 1px solid #ccc;
  border-radius: 8px;
  background: #f8f9fa;
  font-size: 14px;
  min-width: 80px;
}

.file-selector input[type="file"] {
  display: none;
}

.status {
  margin-top: 4px;
  font-size: 8px;
  color: #666;
}
</style>